/*
 * Copyright 2017 Nicola Atzei
 */

import com.google.common.base.Throwables
import it.unica.tcs.bitcoinTM.AddressLiteral
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Constant
import it.unica.tcs.bitcoinTM.DateLiteral
import it.unica.tcs.bitcoinTM.Div
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Hash160
import it.unica.tcs.bitcoinTM.Hash256
import it.unica.tcs.bitcoinTM.HashLiteral
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.InputValue
import it.unica.tcs.bitcoinTM.Interpretable
import it.unica.tcs.bitcoinTM.KeyLiteral
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.PubKeyLiteral
import it.unica.tcs.bitcoinTM.Reference
import it.unica.tcs.bitcoinTM.Ripemd160
import it.unica.tcs.bitcoinTM.Sha1
import it.unica.tcs.bitcoinTM.Sha256
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureLiteral
import it.unica.tcs.bitcoinTM.SignaturePlaceholder
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.Times
import it.unica.tcs.bitcoinTM.Transaction
import it.unica.tcs.bitcoinTM.TransactionHexLiteral
import it.unica.tcs.bitcoinTM.TransactionIDLiteral
import it.unica.tcs.lib.Hash
import it.unica.tcs.lib.Hash.HashAlgorithm
import it.unica.tcs.lib.ITransactionBuilder
import it.unica.tcs.lib.utils.BitcoinUtils
import it.unica.tcs.utils.ASTUtils
import it.unica.tcs.utils.BitcoinClientFactory
import it.unica.tcs.utils.SignatureAndPubkey
import java.math.BigInteger
import java.security.KeyStoreException
import org.apache.log4j.Logger
import org.bitcoinj.core.Address
import org.bitcoinj.core.DumpedPrivateKey
import org.bitcoinj.core.ECKey
import org.bitcoinj.core.Utils
import org.eclipse.xtext.EcoreUtil2

system it.unica.tcs.xsemantics.BitcoinTMInterpreter

inject extension ASTUtils astUtils
inject extension TransactionCompilerDelegate compiler
inject BitcoinClientFactory clientFactory

val logger = Logger.getLogger(BitcoinTMInterpreter)

judgments {
    interpret |- Interpretable expression |> Rho rho ~> output Object
    interpretE |- Interpretable expression ~> output Object
}


/*
 * Interpret with an empty rho
 */
rule InterpretE
    G |- Interpretable v ~> Object res
from {
    G |- v |> new Rho() ~> res
}

/*
 * Interpret
 */
rule InterpretReference
    G |- Reference v |> Rho rho ~> Object res
from {
    if (rho.isAlreadyVisited(v.ref)) {
        fail
            error "Found cyclic dependency"
            source v
    }

    if (logger.isTraceEnabled) {        
        if (G.get("tab")===null) G.add("tab","")
        logger.trace(G.get("tab")+"INTERPRET: "+astUtils.nodeToString(v)+" ("+v.ref.class.simpleName+")"+" rho:"+rho)
        G.add("tab", G.get("tab")+"|\t")
    }
    
    if (v.ref instanceof Transaction) {
        val tx = v.ref as Transaction
        // create a fresh rho to evaluate T
        val newRho = rho.fresh
        for (var i=0; i<v.actualParams.size; i++) {
            val actual = v.actualParams.get(i)
            val formal = tx.params.get(i)

            G |- actual |> rho ~> var Object value
            newRho.put(formal, value)
        }
        G |- tx |> newRho ~> res
    }
    else if (v.ref instanceof Constant) {
        // Constant
        val const = v.ref as Constant
        G |- const.exp |> rho.fresh ~> res
    }
    else if (v.ref instanceof Parameter) {
        // Parameter
        val param = v.ref as Parameter
        { rho.containsKey(param) }
        res = rho.get(param)
    }
    
    if (logger.isTraceEnabled) {
        G.add("tab", (G.get("tab") as String).substring(2))
        logger.trace(G.get("tab")+"RESULT: "+res)        
    }
}

axiom InterpretSignaturePlaceholder
    G |- SignaturePlaceholder p |> Rho rho ~> SignatureAndPubkey.placeholder

axiom InterpretNumberLiteral
    G |- NumberLiteral number |> Rho rho ~> number.value

axiom InterpretStringLiteral
    G |- StringLiteral str |> Rho rho ~> str.value

axiom InterpretBooleanLiteral
    G |- BooleanLiteral bool |> Rho rho ~> bool.^true

axiom InterpretHashLiteral
    G |- HashLiteral hash |> Rho rho ~> new Hash(hash.value)

rule InterpretSignatureLiteral
    G |- SignatureLiteral s |> Rho rho ~> SignatureAndPubkey result
from {
    G |- s.key |> rho ~> var Object key
    val eckey = if (key instanceof DumpedPrivateKey)
        key.key
    else
        key as ECKey
    result = new SignatureAndPubkey(BitcoinUtils.decode(s.value), eckey.pubKey)
}

axiom InterpretDateLiteral
    G |- DateLiteral d |> Rho rho ~> d.value

axiom InterpretTransactionHexLiteral
    G |- TransactionHexLiteral tx |> Rho rho ~> ITransactionBuilder.fromSerializedTransaction(tx.networkParams, BitcoinUtils.decode(tx.value))

rule InterpretTransactionIDLiteral
    G |- TransactionIDLiteral tx |> Rho rho ~> ITransactionBuilder res
from {
    val id = tx.value
    val client = clientFactory.getBitcoinClient(tx.networkParams)

    try {
        val hex = client.getRawTransaction(id);
        res = ITransactionBuilder.fromSerializedTransaction(tx.networkParams, BitcoinUtils.decode(hex))
    }
    catch (Exception e) {
        fail
            error "Cannot interpret transaction with ID "+id+". Error: "+Throwables.getStackTraceAsString(e)
            source tx
    }
}

rule InterpretSignature
    G |- Signature s |> Rho rho ~> SignatureAndPubkey res
from {
    { s.hasTx }

    G |- s.privkey |> rho ~> var Object key
    G |- s.tx |> rho ~> var ITransactionBuilder txBuilder

    if (!(key instanceof DumpedPrivateKey)) {
        fail
            error "Key must be private"
            source s.privkey
    }

    try {
        val tx = txBuilder.toTransaction(s.ECKeyStore)
        val inputIndex = s.inputIdx as int
        val sigHashType = astUtils.toHashType(s.modifier)
        val anyonecanpay = astUtils.toAnyoneCanPay(s.modifier)
    
        val input = txBuilder.inputs.get(inputIndex)
        val outScript = input.parentTx.outputs.get(input.outIndex).script.build.program
    
        val privkey = key as DumpedPrivateKey 
        val pubkey = ECKey.fromPublicOnly(privkey.key.pubKey)
    
        val sig = tx.calculateSignature(
            inputIndex,
            (key as DumpedPrivateKey).key,
            outScript,
            sigHashType,
            anyonecanpay
        )
        
        res = new SignatureAndPubkey(sig.encodeToBitcoin, pubkey.pubKey)        
    }
    catch (KeyStoreException e) {
        fail
            error "Error occurred when generating the keystore"
            source s
    }
}

axiom InterpretKeyLiteral
    G |- KeyLiteral key |> Rho rho ~> DumpedPrivateKey.fromBase58(null, key.value)

axiom InterpretAddressLiteral
    G |- AddressLiteral addr |> Rho rho ~> Address.fromString(null, addr.value)

axiom InterpretPubkeyLiteral
    G |- PubKeyLiteral d |> Rho rho ~> ECKey.fromPublicOnly(BitcoinUtils.decode(d.value))

rule InterpretTransaction
    G |- Transaction tx |> Rho rho ~> ITransactionBuilder res
from {
    val txBuilder = tx.compileTransaction(rho)

    if (!txBuilder.isReady) {
        fail
            error "Transaction must be ready"
            source tx
    }
    res = txBuilder
}

rule InterpretMinus
    G |- Minus minus |> Rho rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult - rightResult
}

rule InterpretTimes
    G |- Times minus |> Rho rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult * rightResult
}

rule InterpretDiv
    G |- Div minus |> Rho rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult / rightResult
}

rule InterpretPlus
    G |- Plus plus |> Rho rho ~> Object result
from {
    G |- plus.left |> rho ~> var Object leftResult
    G |- plus.right |> rho ~> var Object rightResult

    if (leftResult instanceof String || rightResult instanceof String) {
        var leftString = leftResult.toString
        var rightString = rightResult.toString
        result = leftString + rightString
    } else {
        // both are int if the expression is well-typed
        var leftInt = leftResult as Long
        var rightInt = rightResult as Long
        result = leftInt + rightInt
    }
}

rule InterpretArithmeticSigned
    G |- ArithmeticSigned signed |> Rho rho ~> Long result
from {
    G |- signed.exp |> rho ~> var Long expResult
    result = -(expResult)
}

rule InterpretAnd
    G |- AndExpression and |> Rho rho ~> Boolean result
from {
    {
        G |- and.left |> rho ~> var Boolean leftResult

        if (leftResult == false) {
            result = false
        }
        else {
            G |- and.right |> rho ~> var Boolean rightResult
            result = rightResult.booleanValue
        }
    } or {
        G |- and.right |> rho ~> var Boolean rightResult

        if (rightResult == false) {
            result = false
        }
        else {
            G |- and.left |> rho ~> var Boolean leftResult
            result = leftResult.booleanValue
        }
    }
}

rule InterpretOr
    G |- OrExpression orExp |> Rho rho ~> Boolean result
from {
    {
        G |- orExp.left |> rho ~> var Boolean leftResult

        if (leftResult == true) {
            result = true
        }
        else {
            G |- orExp.right |> rho ~> var Boolean rightResult
            result = rightResult.booleanValue
        }
    } or {
        G |- orExp.right |> rho ~> var Boolean rightResult

        if (rightResult == true) {
            result = true
        }
        else {
            G |- orExp.left |> rho ~> var Boolean leftResult
            result = leftResult.booleanValue
        }
    }
}

rule InterpretBooleanNegation
    G |- BooleanNegation neg |> Rho rho ~> Boolean result
from {
    G |- neg.exp |> rho ~> var Boolean expResult
    result = !expResult
}

rule InterpretComparison
    G |- Comparison comparison |> Rho rho ~> Boolean result
from {
    G |- comparison.left |> rho ~> var Comparable<Object> leftResult
    G |- comparison.right |> rho ~> var Object rightResult

    result = switch(comparison.op) {
            case ">=": leftResult >= rightResult
            case "<=": leftResult <= rightResult
            case ">": leftResult > rightResult
            case "<": leftResult < rightResult
            default: null
        }

    if (result===null) {
        fail
            error "Unexpected operator "+comparison.op
            source comparison
    }
}

rule InterpretEquals
    G |- Equals comparison |> Rho rho ~> Boolean result
from {

    {
        G |- comparison.left |> rho ~> var ITransactionBuilder leftResult
        G |- comparison.right |> rho ~> var ITransactionBuilder rightResult

        var areEqual = ITransactionBuilder.equals(leftResult,rightResult)

        result = switch(comparison.op) {
            case "==": areEqual
            case "!=": !areEqual
            default: null
        }

        if (result===null) {
            fail
                error "Unexpected operator "+comparison.op
                source comparison
        }

    } or {
        comparison.left instanceof Reference
        comparison.right instanceof Reference
        // two refs are the same if they point to the same parameter
        var leftResult = (comparison.left as Reference).ref
        var rightResult = (comparison.right as Reference).ref
        leftResult == rightResult

        result = switch(comparison.op) {
            case "==": true
            case "!=": false
            default: null
        }

        if (result===null) {
            fail
                error "Unexpecter operator "+comparison.op
                source comparison
        }

    } or {
        G |- comparison.left |> rho ~> var Object leftResult
        G |- comparison.right |> rho ~> var Object rightResult

        var areEqual = leftResult==rightResult

        result = switch(comparison.op) {
            case "==": areEqual
            case "!=": !areEqual
            default: null
        }

        if (result===null) {
            fail
                error "Unexpected operator "+comparison.op
                source comparison
        }
    }
}

rule InterpretIfThenElse
    G |- IfThenElse stmt |> Rho rho ~> Object result
from {
    G |- stmt.^if |> rho ~> var Boolean ifCondition

    if (ifCondition) {
        G |- stmt.then |> rho ~> var Object thenResult
        result = thenResult
    }
    else {
        G |- stmt.^else |> rho ~> var Object elseResult
        result = elseResult
    }
}

rule InterpretMin
    G |- Min stmt |> Rho rho ~> Long result
from {
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes

    if (leftRes<=rightRes)
        result = leftRes
    else
        result = rightRes
}

rule InterpretMax
    G |- Max stmt |> Rho rho ~> Long result
from {
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes

    if (leftRes>=rightRes)
        result = leftRes
    else
        result = rightRes
}

rule InterpretBetween
    G |- Between stmt |> Rho rho ~> Boolean result
from {
    G |- stmt.value |> rho ~> var Long valueRes
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes
    result = leftRes<=valueRes && valueRes<rightRes
}

rule InterpretHash
    G |- it.unica.tcs.bitcoinTM.Hash hash |> Rho rho ~> Hash result
from {

    G |- hash.value |> rho ~> var Object expResult

    // hash the bytes
    if (hash instanceof Hash160)
        result = BitcoinUtils.hash(expResult, HashAlgorithm.HASH160)
    else if (hash instanceof Hash256)
        result = BitcoinUtils.hash(expResult, HashAlgorithm.HASH256)
    else if (hash instanceof Ripemd160)
        result = BitcoinUtils.hash(expResult, HashAlgorithm.RIPEMD160)
    else if (hash instanceof Sha256)
        result = BitcoinUtils.hash(expResult, HashAlgorithm.SHA256)
    else if (hash instanceof Sha1)
        result = BitcoinUtils.hash(expResult, HashAlgorithm.SHA1)
    else {
        fail
        error "Unexpected instance "+hash.class
        source hash
    }
}

rule InterpretSize
    G |- Size size |> Rho rho ~> Long result
from {
    G |- size.value |> rho ~> var Long res

    if (res==0)
        result=0L
    else {
        // ⌈(log2 |n| / 7)⌉
        result = Long.valueOf(Utils.encodeMPI(BigInteger.valueOf(res), false).length)
    }
}

rule InterpretInputValue
    G |- InputValue stmt |> Rho rho ~> Long result
from {
    val containingTx = EcoreUtil2.getContainerOfType(stmt, Transaction);
    var value = 0L;

    for (idx : stmt.inputIdxs) {
        val outIdx = containingTx.inputs.get(idx.intValue).outpoint.intValue
        G |- containingTx.inputs.get(idx.intValue).txRef |> rho ~> var ITransactionBuilder inTx    
        value += inTx.outputs.get(outIdx).value
    }

    if (stmt.inputIdxs.^empty) {
        for (input : containingTx.inputs) {
            val outIdx = input.outpoint.intValue
            G |- input.txRef |> rho ~> var ITransactionBuilder inTx    
            value += inTx.outputs.get(outIdx).value
        }
    }
    result = value;
}
