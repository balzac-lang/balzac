/*
 * Copyright 2017 Nicola Atzei
 */

import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Constant
import it.unica.tcs.bitcoinTM.DateLiteral
import it.unica.tcs.bitcoinTM.Div
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Hash160
import it.unica.tcs.bitcoinTM.Hash160Literal
import it.unica.tcs.bitcoinTM.Hash256
import it.unica.tcs.bitcoinTM.Hash256Literal
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Interpretable
import it.unica.tcs.bitcoinTM.KeyLiteral
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Reference
import it.unica.tcs.bitcoinTM.Ripemd160
import it.unica.tcs.bitcoinTM.Ripemd160Literal
import it.unica.tcs.bitcoinTM.Sha256
import it.unica.tcs.bitcoinTM.Sha256Literal
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureLiteral
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.Times
import it.unica.tcs.bitcoinTM.Transaction
import it.unica.tcs.bitcoinTM.TransactionLiteral
import it.unica.tcs.lib.Hash
import it.unica.tcs.lib.ITransactionBuilder
import it.unica.tcs.lib.utils.BitcoinUtils
import it.unica.tcs.utils.ASTUtils
import java.math.BigInteger
import org.bitcoinj.core.Address
import org.bitcoinj.core.DumpedPrivateKey
import org.bitcoinj.core.Utils
import org.bitcoinj.crypto.TransactionSignature

system it.unica.tcs.xsemantics.BitcoinTMInterpreter

inject extension ASTUtils astUtils
inject extension TransactionCompilerDelegate compiler

judgments {
    interpret |- Interpretable expression |> Rho rho ~> output Object
    interpretE |- Interpretable expression ~> output Object
}


/*
 * Interpret with an empty rho
 */
rule InterpretE
    G |- Interpretable v ~> Object res
from {
    G |- v |> new Rho() ~> res
}

/*
 * Interpret
 */
rule InterpretReference
    G |- Reference v |> Rho rho ~> Object res
from {
    if (v.ref instanceof Transaction) {
        val tx = v.ref as Transaction

        for (var i=0; i<v.actualParams.size; i++) {
            val actual = v.actualParams.get(i)
            val formal = tx.params.get(i)

            G |- actual |> rho ~> var Object value
            rho.put(formal, value)
        }

        G |- tx |> rho ~> res
    }
    else if (v.ref instanceof Constant) {
        // Constant
        val const = v.ref as Constant
        G |- const.exp |> rho ~> res
    }
    else if (v.ref instanceof Parameter) {
        // Parameter
        val param = v.ref as Parameter
        {rho.containsKey(param)}
        res = rho.get(param)
    }
}

axiom InterpretNumberLiteral
    G |- NumberLiteral number |> Rho rho ~> number.value

axiom InterpretStringLiteral
    G |- StringLiteral str |> Rho rho ~> str.value

axiom InterpretBooleanLiteral
    G |- BooleanLiteral bool |> Rho rho ~> bool.^true

axiom InterpretHash160Literal
    G |- Hash160Literal hash |> Rho rho ~> new Hash.Hash160(hash.value)

axiom InterpretHash256Literal
    G |- Hash256Literal hash |> Rho rho ~> new Hash.Hash256(hash.value)

axiom InterpretRipemd160Literal
    G |- Ripemd160Literal hash |> Rho rho ~> new Hash.Ripemd160(hash.value)

axiom InterpretSha256Literal
    G |- Sha256Literal hash |> Rho rho ~> new Hash.Sha256(hash.value)

axiom InterpretSignatureLiteral
    G |- SignatureLiteral s |> Rho rho ~> TransactionSignature.decodeFromBitcoin(BitcoinUtils.decode(s.value), true, false)

axiom InterpretDateLiteral
    G |- DateLiteral d |> Rho rho ~> d.value

axiom InterpretTransactionLiteral
    G |- TransactionLiteral tx |> Rho rho ~> ITransactionBuilder.fromSerializedTransaction(tx.networkParams, BitcoinUtils.decode(tx.value))

rule InterpretSignature
    G |- Signature s |> Rho rho ~> TransactionSignature res
from {
    { s.tx !== null }

    G |- s.privkey |> rho ~> var Object key
    G |- s.tx |> rho ~> var ITransactionBuilder txBuilder

    if (!(key instanceof DumpedPrivateKey)) {
        fail
            error "Key must be private"
            source s.privkey
    }

    val tx = txBuilder.toTransaction
    val inputIndex = s.inputIdx
    val sigHashType = astUtils.toHashType(s.modifier)
    val anyonecanpay = astUtils.toAnyoneCanPay(s.modifier)

    val input = txBuilder.inputs.get(inputIndex as int)
    val outScript = input.parentTx.outputs.get(input.outIndex).script.build.program

    res = tx.calculateSignature(
        0,
        (key as DumpedPrivateKey).key,
        outScript,
        sigHashType,
        anyonecanpay
    )
}

rule InterpretKeyLiteral
    G |- KeyLiteral key |> Rho rho ~> Object res
from {
    {
        res = DumpedPrivateKey.fromBase58(null, key.value);
    } or {
        res = Address.fromBase58(null, key.value);
    }
}

rule InterpretTransaction
    G |- Transaction tx |> Rho rho ~> ITransactionBuilder res
from {

    val txBuilder = tx.compileTransaction(rho)

    if (!txBuilder.isReady) {
        fail
            error "Transaction must be ready"
            source tx
    }

    res = txBuilder
}

rule InterpretMinus
    G |- Minus minus |> Rho rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult - rightResult
}

rule InterpretTimes
    G |- Times minus |> Rho rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult * rightResult
}

rule InterpretDiv
    G |- Div minus |> Rho rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult / rightResult
}

rule InterpretPlus
    G |- Plus plus |> Rho rho ~> Object result
from {
    G |- plus.left |> rho ~> var Object leftResult
    G |- plus.right |> rho ~> var Object rightResult

    if (leftResult instanceof String || rightResult instanceof String) {
        var leftString = leftResult.toString
        var rightString = rightResult.toString
        result = leftString + rightString
    } else {
        // both are int if the expression is well-typed
        var leftInt = leftResult as Long
        var rightInt = rightResult as Long
        result = leftInt + rightInt
    }
}

rule InterpretArithmeticSigned
    G |- ArithmeticSigned signed |> Rho rho ~> Long result
from {
    G |- signed.exp |> rho ~> var Long expResult
    result = -(expResult)
}

rule InterpretAnd
    G |- AndExpression and |> Rho rho ~> Boolean result
from {
    {
        G |- and.left |> rho ~> var Boolean leftResult

        if (leftResult == false) {
            result = false
        }
        else {
            G |- and.right |> rho ~> var Boolean rightResult
            result = rightResult.booleanValue
        }
    } or {
        G |- and.right |> rho ~> var Boolean rightResult

        if (rightResult == false) {
            result = false
        }
        else {
            G |- and.left |> rho ~> var Boolean leftResult
            result = leftResult.booleanValue
        }
    }
}

rule InterpretOr
    G |- OrExpression orExp |> Rho rho ~> Boolean result
from {
    {
        G |- orExp.left |> rho ~> var Boolean leftResult

        if (leftResult == true) {
            result = true
        }
        else {
            G |- orExp.right |> rho ~> var Boolean rightResult
            result = rightResult.booleanValue
        }
    } or {
        G |- orExp.right |> rho ~> var Boolean rightResult

        if (rightResult == true) {
            result = true
        }
        else {
            G |- orExp.left |> rho ~> var Boolean leftResult
            result = leftResult.booleanValue
        }
    }
}

rule InterpretBooleanNegation
    G |- BooleanNegation neg |> Rho rho ~> Boolean result
from {
    G |- neg.exp |> rho ~> var Boolean expResult
    result = !expResult
}

rule InterpretComparison
    G |- Comparison comparison |> Rho rho ~> Boolean result
from {
    G |- comparison.left |> rho ~> var Comparable<Object> leftResult
    G |- comparison.right |> rho ~> var Object rightResult

    result = switch(comparison.op) {
            case ">=": leftResult >= rightResult
            case "<=": leftResult <= rightResult
            case ">": leftResult > rightResult
            case "<": leftResult < rightResult
            default: null
        }

    if (result===null) {
        fail
            error "Unexpected operator "+comparison.op
            source comparison
    }
}

rule InterpretEquals
    G |- Equals comparison |> Rho rho ~> Boolean result
from {

    {
        G |- comparison.left |> rho ~> var ITransactionBuilder leftResult
        G |- comparison.right |> rho ~> var ITransactionBuilder rightResult

        var areEqual = ITransactionBuilder.equals(leftResult,rightResult)

        result = switch(comparison.op) {
            case "==": areEqual
            case "!=": !areEqual
            default: null
        }

        if (result===null) {
            fail
                error "Unexpected operator "+comparison.op
                source comparison
        }

    } or {
        comparison.left instanceof Reference
        comparison.right instanceof Reference
        // two refs are the same if they point to the same parameter
        var leftResult = (comparison.left as Reference).ref
        var rightResult = (comparison.right as Reference).ref
        leftResult == rightResult

        result = switch(comparison.op) {
            case "==": true
            case "!=": false
            default: null
        }

        if (result===null) {
            fail
                error "Unexpecter operator "+comparison.op
                source comparison
        }

    } or {
        G |- comparison.left |> rho ~> var Object leftResult
        G |- comparison.right |> rho ~> var Object rightResult

        var areEqual = leftResult==rightResult

        result = switch(comparison.op) {
            case "==": areEqual
            case "!=": !areEqual
            default: null
        }

        if (result===null) {
            fail
                error "Unexpected operator "+comparison.op
                source comparison
        }
    }
}

rule InterpretIfThenElse
    G |- IfThenElse stmt |> Rho rho ~> Object result
from {
    G |- stmt.^if |> rho ~> var Boolean ifCondition

    if (ifCondition) {
        G |- stmt.then |> rho ~> var Object thenResult
        result = thenResult
    }
    else {
        G |- stmt.^else |> rho ~> var Object elseResult
        result = elseResult
    }
}

rule InterpretMin
    G |- Min stmt |> Rho rho ~> Long result
from {
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes

    if (leftRes<=rightRes)
        result = leftRes
    else
        result = rightRes
}

rule InterpretMax
    G |- Max stmt |> Rho rho ~> Long result
from {
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes

    if (leftRes>=rightRes)
        result = leftRes
    else
        result = rightRes
}

rule InterpretBetween
    G |- Between stmt |> Rho rho ~> Boolean result
from {
    G |- stmt.value |> rho ~> var Long valueRes
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes
    result = leftRes<=valueRes && valueRes<rightRes
}

rule InterpretHash
    G |- it.unica.tcs.bitcoinTM.Hash hash |> Rho rho ~> Hash result
from {

    G |- hash.value |> rho ~> var Object expResult

    // hash the bytes
    if (hash instanceof Hash160)
        result = BitcoinUtils.hash(expResult, Hash.Hash160)
    else if (hash instanceof Hash256)
        result = BitcoinUtils.hash(expResult, Hash.Hash256)
    else if (hash instanceof Ripemd160)
        result = BitcoinUtils.hash(expResult, Hash.Ripemd160)
    else if (hash instanceof Sha256)
        result = BitcoinUtils.hash(expResult, Hash.Sha256)
    else {
        fail
        error "Unexpected instance "+hash.class
        source hash
    }
}

rule InterpretSize
    G |- Size size |> Rho rho ~> Long result
from {
    G |- size.value |> rho ~> var Long res

    if (res==0)
        result=0L
    else {
        // ⌈(log2 |n| / 7)⌉
        result = Long.valueOf(Utils.encodeMPI(BigInteger.valueOf(res), false).length)
    }
}