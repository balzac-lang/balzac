/*
 * Copyright 2019 Nicola Atzei
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * generated by Xtext 2.14.0
 */
package xyz.balzaclang.ui.codemining;

import java.util.Iterator;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.codemining.ICodeMining;
import org.eclipse.xsemantics.runtime.Result;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ui.codemining.AbstractXtextCodeMiningProvider;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.util.IAcceptor;

import com.google.inject.Inject;

import xyz.balzaclang.balzac.Constant;
import xyz.balzaclang.balzac.Type;
import xyz.balzaclang.services.BalzacGrammarAccess;
import xyz.balzaclang.xsemantics.BalzacStringRepresentation;
import xyz.balzaclang.xsemantics.BalzacTypeSystem;
import xyz.balzaclang.xsemantics.TypeSubstitutions;

@SuppressWarnings("restriction")
public class BalzacCodeMiningProvider extends AbstractXtextCodeMiningProvider {

    @Inject private BalzacGrammarAccess grammar;
    @Inject private BalzacTypeSystem typeSystem;
    @Inject private BalzacStringRepresentation strRep;

    @Override
    protected void createCodeMinings(IDocument document, XtextResource resource, CancelIndicator indicator,
        IAcceptor<? super ICodeMining> acceptor) throws BadLocationException {

        // get all operations to open document
        List<Constant> allConstants = EcoreUtil2.eAllOfType(resource.getContents().get(0), Constant.class);

        Keyword colon = grammar.getConstantAccess().getColonKeyword_2_0();
        Keyword equalsSign = grammar.getConstantAccess().getEqualsSignKeyword_3();

        for (Constant c : allConstants) {
            // find document offset for inline annotation
            ICompositeNode node = NodeModelUtils.findActualNodeFor(c);

            boolean hasType = false;
            for (Iterator<INode> it = node.getAsTreeIterable().iterator(); it.hasNext();) {
                INode child = it.next();
                if (colon.equals(child.getGrammarElement())) {
                    hasType = true;
                }
                if (!hasType && equalsSign.equals(child.getGrammarElement())) {
                    // create line content code mining for inline annotation after grammarElement ')'
                    Result<Type> res = typeSystem.typeExpression(new TypeSubstitutions(), c);
                    if (!res.failed()) {
                        String annotationText = ": " + strRep.stringRep(res.getFirst())+" ";
                        acceptor.accept(createNewLineContentCodeMining(child.getTotalOffset(), annotationText));
                    }
                }
            }
        }

        // TODO: implement me
        // use acceptor.accept(super.createNewLineHeaderCodeMining(...)) to add a new code mining to the final list

        // example:
        // acceptor.accept(createNewLineHeaderCodeMining(1, document, "Header annotation"));
    }
}
